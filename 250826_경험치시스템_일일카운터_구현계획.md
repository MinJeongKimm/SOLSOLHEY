# 경험치(EXP) 시스템 – 일일 카운터(MVP) 구현 계획 (2025-08-26)

본 문서는 “일일 카운터” 방식으로 EXP 자동 적립을 최소 변경으로 도입하기 위한 백엔드/프론트 설계와 한계점을 정리합니다. 현재 레포지토리 파일은 수정하지 않으며, 구현 가이드만 제시합니다. 요구사항은 이전 계획과 동일합니다(챌린지는 포인트 보상만, EXP는 자동 적립: 출석 +5, 7연속 +20, 친구 상호작용 +3(일 3회), 챌린지 카테고리별 참여 +5(카테고리당 일 1회)).

업데이트(2025-08-27)
- 규칙/설계 보완(아래 내용이 본문보다 우선 적용됩니다)
  - 출석: +5 EXP, 7연속 +20 EXP(그 외 보너스 없음). 컨트롤러 성공 응답은 조건 충족 시에만 `expAwarded`를 포함하며, 기존 `expReward`는 사용/노출하지 않습니다(추후 제거).
  - 친구 상호작용(방문 기준):
    - 내가 친구를 방문(발신자=나): 오늘 선착 3회 +3 EXP, 4회부터 +1 EXP. 카운터: `friend_active_award_count`.
    - 친구가 나를 방문(수신자=나): 매 이벤트마다 +1 EXP(현 MVP 무제한). 카운터: `friend_passive_award_count`(한도 미적용, 집계/요약용).
    - 향후 수신자 +1에도 일일 한도 도입 시 스키마 변경 없이 설정/로직만으로 전환 가능.
  - 챌린지: 포인트만 지급. EXP는 ‘참여 시’ 카테고리별 1일 1회 +5만 지급. 서버 DTO의 `rewardExp`는 프론트 정리 전까지 0 고정, 이후 비노출/제거.
  - 일일 경계: KST 00:00–24:00 기준. 서버 저장은 UTC, `counter_date`는 `Asia/Seoul` LocalDate로 파생 관리.
  - 마스코트: 생성된 이후에만 EXP 적립. 자동 생성 금지(없으면 적립 스킵 및 `expAwarded` 비포함).
  - 프론트: `expAwarded` 존재 시 토스트 노출, 실표시는 `GET /api/v1/exp/summary`로 동기화. 기존 `expReward` 기반 로컬 가산 중단.

## 결정 사항(요약)
- 현재 요구(사용자에게 EXP 적립 “로그 목록”을 보여줄 필요 없음)를 반영하여, 일일 카운터 방식으로 진행합니다.
- per-event 레저(예: `exp_event` 적립 로그 테이블)는 도입하지 않습니다. 일일 제한 준수와 EXP 누적만 보장합니다.
- 백엔드는 카운터 테이블 + 카운터 서비스(조건 판단/EXP 누적) + 요약 조회 API에 집중합니다.
- 프론트는 챌린지 화면의 경험치 탭을 제거하고, 메인 캐릭터 하단 EXP/레벨 클릭 시 요약만 노출합니다.

## 1) 현재 코드 기준 분석 요약
- 자동 EXP 적립 로직: 없음. 출석/친구/챌린지 플로우에 EXP 적립이 연결되어 있지 않음.
  - 출석: `AttendanceServiceImpl.checkInToday`는 출석 이력 저장 후 포인트 보너스만 지급.
  - 친구 상호작용: `FriendServiceImpl.sendInteraction`는 상호작용 저장만.
  - 챌린지: `ChallengeServiceImpl.joinChallenge`는 참여 저장만(완료 시 포인트 보상은 별도), EXP 적립 없음.
- 마스코트: `Mascot(exp, level)` 존재, `MascotServiceImpl.updateMascot`로 수동 EXP 증가 가능(자동 적립 연동 없음).
- EXP 이력/제한/조회: 관련 테이블·서비스·API 부재.

## 2) 일일 카운터 방식 개요
- 목표: “오늘 횟수/여부”만 저장하여 규칙을 충족하면 EXP를 즉시 누적하고, 상세 이벤트 이력(건별 로그) 없이도 일일 제한을 지킴.
- 핵심 데이터: 사용자별 ‘오늘 출석 적립 여부’, ‘오늘 카테고리별 챌린지 참여 적립 여부’, ‘오늘 친구 상호작용 적립 카운트’만 관리.
 - 이벤트 레저/적립 로그는 저장하지 않음(현재 범위에서 불필요).

### 2.1 데이터 모델(신규, 제안)
선택 A: 단일 로우(denormalized) – 간단하고 빠름(MVP 추천)
- 테이블: `exp_daily_counter`
  - `id` (PK)
  - `user_id` (FK → users)
  - `counter_date` (DATE, user 기준 타임존 고려)
  - `attendance_awarded` (boolean)
  - `attendance_streak7_awarded` (boolean)
  - `friend_active_award_count` (int)  // 내가 방문하여 적립한 횟수(선착 3회 +3 판단용)
  - `friend_passive_award_count` (int) // 내가 방문받아 +1 적립된 누계(현 MVP 한도 없음)
  - `cat_finance_awarded` (boolean)
  - `cat_academic_awarded` (boolean)
  - `cat_social_awarded` (boolean)
  - `cat_event_awarded` (boolean)
  - `created_at`, `updated_at`
- 제약/인덱스: UNIQUE(`user_id`, `counter_date`), 인덱스(`user_id`, `counter_date`).

선택 B: 정규화(유형별 행) – 확장성 좋으나 구현량 증가(이번 MVP 비권장)
- `exp_daily_counter(user_id, date, event_type, category?, count)` 구조. 여기서는 생략.

### 2.2 서비스 로직(신규)
- `ExpDailyCounterService` (MVP용 간소 서비스)
  - `awardAttendanceExp(User user, int consecutiveDays)`
    - 오늘 카운터 로우 upsert.
    - `attendance_awarded == false`면 +5 EXP 부여 후 true로 세팅.
    - `consecutiveDays >= 7`이고 `attendance_streak7_awarded == false`면 추가 +20 EXP 부여 후 true.
  - `awardFriendInteractionExpActive(User actor)`
    - 오늘 `friend_active_award_count < 3`이면 +3, 아니면 +1 EXP. 이후 active 카운트 +1.
  - `awardFriendInteractionExpPassive(User receiver)`
    - 매 이벤트마다 +1 EXP. 이후 passive 카운트 +1(현 MVP 한도 없음).
  - `awardChallengeCategoryExp(User user, ChallengeCategory.CategoryType cat)`
    - 카테고리별 플래그(false → true)일 때만 +5 EXP.
  - 공통 내부:
    - 오늘 행을 `SELECT ... FOR UPDATE` 또는 UPSERT 후 원자적으로 갱신(경합 시 보너스 초과 방지).
    - EXP 부여는 마스코트에 누적(마스코트 없으면 적립 스킵) → `Mascot.addExp(...)` 호출.
    - 호출자에게 간단한 알림 페이로드(수여량, 이유, 현재 레벨/총EXP) 반환.
    - per-event 로그 저장은 생략(요구사항 범위 밖).

- 트랜잭션: 호출부(출석/상호작용/참여) 저장 트랜잭션 안에서 카운터 갱신 및 EXP 누적까지 함께 커밋(일관성 보장).

### 2.3 기존 플로우에 주입(현재 파일 기준 연결 지점)
- 출석: `backend/solsol/src/main/java/com/solsolhey/user/service/AttendanceServiceImpl.java`
  - `checkInToday(User user)` 성공 후 → `ExpDailyCounterService.awardAttendanceExp(user, consecutiveDays)` 호출하고, 반환된 `expAwarded`를 API 응답에 포함(선택).
- 친구 상호작용: `backend/solsol/src/main/java/com/solsolhey/friend/service/FriendServiceImpl.java`
  - `sendInteraction(User user, FriendInteractionRequest req)` 저장 후 → 발신자에 `awardFriendInteractionExpActive(from)`, 수신자에 `awardFriendInteractionExpPassive(to)` 호출.
- 챌린지 참여: `backend/solsol/src/main/java/com/solsolhey/challenge/service/ChallengeServiceImpl.java`
  - `joinChallenge(Long challengeId, User user)`에서 참여 성공 시 → challenge.category 조회 후 `awardChallengeCategoryExp(user, categoryType)` 호출.

## 3) API 설계(백엔드)
- 기존 API 재사용 + 조건 판단/EXP 적립 결과만 가볍게 포함.
  - 출석/친구/챌린지 참여 성공 응답 바디에 선택 필드 `expAwarded` 추가(예: `{ amount, type, category?, totalExp, level }`).
- 조회(권장, UI 용이):
  - `GET /api/v1/exp/summary`
    - 응답 예: `{ totalExp, level, today: { attendance: boolean, streak7: boolean, friend: { active: { count, remainingTop3: Math.max(0, 3-count) }, passive: { count } }, categories: { FINANCE: boolean, ACADEMIC: boolean, SOCIAL: boolean, EVENT: boolean} } }`
  - (선택) `GET /api/v1/exp/counters/today` – 디버깅/QA용 원시 카운터 제공.

보안: 인증 사용자 본인 데이터만 접근.

## 4) 프론트 반영
- 챌린지 화면의 경험치 탭 제거(혼동 방지). EXP는 챌린지 보상이 아님.
- 메인 화면 캐릭터 하단 EXP/레벨 영역 클릭 → EXP 서머리/최근 적립 현황 모달.
  - 초기 진입 시 `GET /api/v1/exp/summary` 호출.
- 알림: 출석/상호작용/참여 API 응답에 `expAwarded` 존재 시 토스트/팝업 노출(확인 버튼 없이 자동 사라짐).

## 5) 동시성/원자성 처리
- DB 레벨에서 `exp_daily_counter`를 `user_id + counter_date`로 unique.
- 오늘 행 upsert 후 `SELECT ... FOR UPDATE`(또는 `friend_active_award_count` 기준 조건부 UPDATE)로 원자적 증가.
- 트랜잭션 경계 내에서 카운터 갱신과 마스코트 EXP 누적을 함께 수행.

## 6) 일일 카운터 방식의 한계
- 이력 부재: 건별 적립 로그가 없으므로 “언제 어떤 행동으로 몇 EXP를 받았는지” 상세 목록/감사 추적/환수 처리가 어려움.
- 근거 희박: 요약 화면은 “오늘 상태/누적만” 제공. 과거 특정 일의 원인 추적이 필요하면 소스 도메인(출석/상호작용/참여)과 추가 조합이 필요.
- 기준/중복 제어 취약: 동일 행동의 중복 방지를 참조 ID 단위로 보장하기 어려움(예: 같은 상호작용 유형의 반복성 중복 처리).
- 향후 확장 제약: 규칙 추가/변경(가중치, 특별 이벤트, 환불/보정) 시 컬럼이 계속 늘어나거나 로직이 복잡해짐.
- 장애 대응 난이도: 카운터만으로는 잘못된 적립을 세밀하게 되돌리기 어렵고, 사용자별 수동 보정이 필요.

현재 요구(사용자 로그 미노출, 빠른 도입)에서는 위 한계가 수용 가능한 트레이드오프로 판단됩니다. 운영·감사 니즈가 생기면 레저형(이벤트 로그)으로 확장합니다.

## 7-bis) 확장 경로(선택)
- 향후 운영/감사/환수/세밀 중복 방지 필요 시, `exp_event` 레저 테이블을 도입하여 본 카운터를 보조 또는 대체.
- 전환 전략: 우선 카운터 유지 + 레저 병행 저장 → 검증 후 카운터 축소/제거.

## 7) 단계별 구현안(MVP)
1. 스키마
   - `exp_daily_counter` 테이블 추가 및 UNIQUE(user_id, counter_date) 설정.
2. 서비스
   - `ExpDailyCounterService` 구현(오늘 로우 upsert/잠금, 규칙 체크, 마스코트 EXP 누적, 알림 페이로드 생성).
3. 기존 플로우 주입
   - 출석/친구/챌린지 참여 성공 지점에 서비스 호출 추가.
4. 조회 API
   - `GET /api/v1/exp/summary` 구현.
5. 프론트
   - 챌린지 화면 경험치 탭 제거, 메인 EXP/레벨 클릭 시 서머리 모달.
   - 응답 내 `expAwarded` 토스트 표시.
6. 테스트
   - 단위: 카운터 증가/한도, 경합 시 초과 방지.
   - 통합: 출석/상호작용/참여 플로우에서 상태/알림 검증.

## 8) 결론
- 일일 카운터는 구현량 대비 효과가 큰 MVP 방안입니다. 다만 상세 이력/감사/환수/유연성 요구가 생기면 추후 레저(exp_event) 기반으로 확장하는 것이 바람직합니다. 초기에는 본 계획으로 빠르게 연결하고, 사용성/운영 요구에 맞춰 단계적으로 고도화하는 전략을 권장합니다.
